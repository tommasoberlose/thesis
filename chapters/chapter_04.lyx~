#LyX 2.2 created this file. For more info see http://www.lyx.org/
\lyxformat 508
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass extreport
\options openright,cleardoublepage=empty
\use_default_options false
\maintain_unincluded_children false
\language italian
\language_package default
\inputencoding utf8
\fontencoding T1
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize 12
\spacing single
\use_hyperref true
\pdf_bookmarks false
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder false
\pdf_colorlinks false
\pdf_backref section
\pdf_pdfusetitle false
\pdf_quoted_options "colorlinks,citecolor=black,filecolor=black,linkcolor=black,urlcolor=black"
\papersize a4paper
\use_geometry true
\use_package amsmath 1
\use_package amssymb 0
\use_package cancel 0
\use_package esint 1
\use_package mathdots 0
\use_package mathtools 0
\use_package mhchem 0
\use_package stackrel 0
\use_package stmaryrd 0
\use_package undertilde 0
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language french
\papercolumns 1
\papersides 2
\paperpagestyle fancy
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
Implementazione
\end_layout

\begin_layout Standard
A seguito della fase di progettazione si è scelto di suddivedere lo sviluppo
 dell'applicazione in alcune fasi principali che seguono logicamente i workflow
 presentati nel dettaglio all'interno del capitolo 2.
 Questo ha permesso di dedicare maggiore attenzione ad ogni componente fino
 ad un livello di dettaglio molto alto, in modo da poter anche ottenere
 una buona valutazione sulle prestazioni dei nodi più critici dell'applicativo.
\end_layout

\begin_layout Standard
Per poter ottenere uno sviluppo abbastanza lineare è stato necessario considerar
e che alcune specifiche richieste erano presenti in tutto il sistema e che
 quindi non potevano essere sviluppate a se stante dagli altri componenti.
 Prima di tutto il design richiesto doveva essere presente in ogni singola
 view e per questo si è deciso di implementare fin da subito l'interfaccia
 utente dell'intera applicazione per non dover replicare ad ogni passaggio
 le stesse operazioni di personalizzazione.
\end_layout

\begin_layout Standard
Strutturato il metodo di sviluppo per la grafica si è passati a gestire
 la navigazione principale scegliendo di utilizzare alcuni dei principali
 pattern Android: il 
\shape italic
NavigationDrawer
\shape default
 e le 
\shape italic
RecyclerView
\shape default
.
 Il menù iniziale è servito a separare anche concettualmente le principali
 funzioni da dover sviluppare così da poter procedere successivamente con
 l'impletazione di ogni componente potendovi accedere anche se altre parti
 dell'applicazione non erano ancora disponibili.
\end_layout

\begin_layout Standard
Ragionando ulteriormente dal generale al dettaglio si è scelto di sviluppare
 la mappa di ricerca degli shop poichè presente in entrambi i flussi logici
 principali e quindi nodo cardine dell'applicazione, specialmente in termini
 di prestazioni.
 La fase successiva ha fornito l'intera gestione della registrazione e dell'aute
nticazione di un utente poichè facente parte sia del sistema di marketing
 sia di quello di e-commerce, ultimi componenti implementati durante la
 fase di sviluppo.
\end_layout

\begin_layout Standard
A conclusione dell'implementazione si sono effettuati dei test per valutare
 le prestazioni dell'applicazione, in particolar modo sui nodi centrali
 che avrebbero potuto inficiare l'esperienza utente se con basse prestazioni,
 come ad esempio la mappa di ricerca.
\end_layout

\begin_layout Section
Design
\end_layout

\begin_layout Standard
Il Design è stata la prima specifica sviluppata poichè avrebbe rappresentato
 una costante durante l'implementazione di qualsiasi schermata dell'applicazione.
 In figura 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Temi"

\end_inset

 sono visualizzati rispettivamente la scelta di due temi differenti, uno
 chiaro e uno scuro con a fianco mostrate le differenze dell'interfaccia
 di navigazione in base al tema selezionato.
 Tutti i componenti sono personalizzati implementando i tre font differenti,
 utilizzando le risorse messe a disposizione sia per le icone che per le
 azioni di navigazione.
\end_layout

\begin_layout Standard
Per incapsulare tutte le funzioni rigurdanti i temi all'interno di un unico
 oggetto si è creata la classe 
\emph on
Flavors 
\emph default
che rappresenta il tema attuale, recuperandolo dalle preferenze dell'applicazion
e, e contiene tutti i dati utili a personalizzare i componenti dell'interfaccia
 come ad esempio il 
\emph on
main
\emph default
 e il 
\emph on
secondary color
\emph default
.
 Questo oggetto viene automaticamente generato unicamente a partire da un
 contesto di una scherata senza dover eseguire nessuna operazione di inizializza
zione.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public class Flavors {
\end_layout

\begin_layout Plain Layout

    Context mContext;
\end_layout

\begin_layout Plain Layout

    ...
\end_layout

\begin_layout Plain Layout

    public int getPrimaryColor();
\end_layout

\begin_layout Plain Layout

    public int getStatusBarColor();
\end_layout

\begin_layout Plain Layout

    public int getPrimaryTextColor();
\end_layout

\begin_layout Plain Layout

    ...
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Ad ogni cambio di tema vi sono elementi dell'UI da aggiornare, in special
 modo tutte le ImageView e le TextView che rappresentano rispettivamente
 ogni immagine e ogni testo presenti sulla schermata.
 Per automatizzare la gestione di questi componenti si è scelto di implementare
 un'interfaccia comune ai due oggetti chiamata 
\emph on
FlavorObject
\emph default
 che dichiarava un nuovo metodo chiamato 
\emph on
updateFlavor()
\emph default
 da richiamare ad ogni aggiornamento e che modifica le proprietà necessarie
 come sfondo, colore e immagini visualizzate.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public interface FlavorObject {
\end_layout

\begin_layout Plain Layout

    public void updateFlavor(Flavors flavor);
\end_layout

\begin_layout Plain Layout

    public void updateFlavor(Context context, String taste);
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Da quest'interfaccia si sono ereditate le tre view principali (
\emph on
CustomImageView, CustomTextView 
\emph default
e
\emph on
 CustomEditTextView
\emph default
) che sono state utilizzate durante tutto lo sviluppo di questa tesi e che
 hanno permesso di richiamare in metodo ricorsivo su tutti i componenti
 lo stesso metodo - 
\emph on
updateFlavor
\emph default
() - in modo da aggiornare la schermata senza dover conoscere esattamente
 come ogni singolo elemento andava modificato.
 Ogni custom view ha quindi implementato il metodo dell'interfaccia così
 da gestire in maniera automatica i temi chiari/scuri e il cambio ad ogni
 aggiornamento.
\end_layout

\begin_layout Standard
Per la gestione dei font dei testi si è sfruttato il fatto di aver implementato
 una versione personalizzata della TextView così da implementare un nuovo
 elemento all'interno del componente scritto in xml.
 Così si è potuto rendere il codice Java molto più pulito indicando il font
 per ogni testo direttamente nella definizione della view all'interno della
 risorsa di tipo 
\emph on
layout
\emph default
 senza dover gestire ogni elemento alla creazione della schermata.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

<com.carpigiani.mygelato.custom.CustomTextView             
\end_layout

\begin_layout Plain Layout

	android:layout_width="wrap_content"
\end_layout

\begin_layout Plain Layout

	android:layout_height="wrap_content"
\end_layout

\begin_layout Plain Layout

	...
\end_layout

\begin_layout Plain Layout

	app:typefaceAsset="fonts/Pacifico.ttf"/>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Per eseguire l'aggiornamento automatico di tutte le view di una schermata
 si è scelto di creare una custom Activity, che rappresenta il componente
 di una schermata dell'interfaccia utente, così da implementare anche in
 questo caso un metodo che venisse richiamato ogni volta che vi erano elementi
 da modificare.
 Questa 
\emph on
FlavorActivity
\emph default
 incapsula la gestione stessa del tema attuale, grazie ad una variabile
 
\emph on
Flavors
\emph default
, aggiornando in maniera automatica oltre agli elementi dichiarati anche
 la toolbar e la statusbar visibili come componenti di sistema di Android.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public class FlavorActivity extends AppCompatActivity {
\end_layout

\begin_layout Plain Layout

    private Flavors flavors;
\end_layout

\begin_layout Plain Layout

    ...
\end_layout

\begin_layout Plain Layout

    @Override     
\end_layout

\begin_layout Plain Layout

	public void onResume() {
\end_layout

\begin_layout Plain Layout

        super.onResume();
\end_layout

\begin_layout Plain Layout

        applyFlavor();
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    public void applyFlavor() {
\end_layout

\begin_layout Plain Layout

        this.flavors = new Flavors(this);
\end_layout

\begin_layout Plain Layout

        updateBar();
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    ...
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Concluso lo sviluppo di ogni componente si è inserita all'interno della
 navigazione principale la possibilità di accedere alla sezione per la scelta
 del tema da parte dell'utente, schermata che elenca ogni tema identificandolo
 con un nome di gelato e alcune immagini personalizzate come si può notare
 in figura 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Temi"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement bh
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename /home/tommaso/Documents/Tesi/thesis/images/temi.jpg
	lyxscale 20
	scale 6

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Temi"

\end_inset

Temi
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Network
\end_layout

\begin_layout Standard
Tutte le funzionalità di collegamento al backend tramite API Rest sono state
 raccolte e incapsulate all'interno di un unico componente utilizzato ad
 ogni chiamata server in maniera standardizzata.
 Sfruttando la libreria OkHttp si è potuto semplificare la gestione delle
 chiamate con protocollo Http potendo incapsulare il risultato in un classe
 
\emph on
Result
\emph default
 contenente i dati sia in caso di errore sia in caso di successo.
\end_layout

\begin_layout Standard
Le API Rest rese disponibili dal backend hanno permesso di standardizzare
 le chiamate richiedendo ad ogni chiamata l'inserimento solo del metodo,
 dei parametri da inviare e dell'eventuale payload.
 Anche la gestione degli errori grazie ai codici identificativi Http hanno
 reso la gestione di tutti gli errori semplificata così da poter visualizzare
 un messaggio di errore il più specifico possibile e localizzato in base
 alla lingua utilizzata sul device.
\end_layout

\begin_layout Standard
Per la gestione della risposta di una richiesta al server la possibilità
 di utilizzare il 
\emph on
Diamond Operator
\emph default
 ha permesso di utilizzare lo stesso oggetto di tipo Result anche con risultato
 di tipo differente, come per esempio i dati relativi ad un utente o ad
 una carta promozionale.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public class Result<T, E> {
\end_layout

\begin_layout Plain Layout

    public T result = null;
\end_layout

\begin_layout Plain Layout

    public E error = null;
\end_layout

\begin_layout Plain Layout

    public Result(T result, E error) {
\end_layout

\begin_layout Plain Layout

        this.result = result;
\end_layout

\begin_layout Plain Layout

        this.error = error;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
L'utilizzo di un middleware così sviluppato per ogni chiamata al backend
 ha permesso anche di inserire alcuni controlli su ogni tipo di richiesta,
 per esempio la possibilità di verificare che le chiamate autenticate non
 dessero come risultato il codice 401 in caso di utente non autorizzato;
 situazione che doveva invocare il logout dell'attuale utente dall'applicazione.
\end_layout

\begin_layout Standard
L'utilizzo dell'oggetto Network, che esponeva i metodi statici necessari
 all'utilizzo delle sue funzionalità in ogni punto dell'applicazione, è
 stato ogni volta inserito all'interno di un componente 
\emph on
AsyncTask
\emph default
 che permette l'esecuzione di un blocco di codice in maniera asincrona dal
 processo principale, migliorando di gran lunga le performance dell'applicazione.
\end_layout

\begin_layout Section
Utente
\end_layout

\begin_layout Standard
Lo sviluppo della sezione legata all'utente è iniziata con la realizzazione
 di un modello, definito all'interno della classe 
\emph on
User
\emph default
, che racchiude tutte le informazioni legate ad un account.
 Utilizzando Realm è stato possibile definire un oggetto che lo rappresenta,
 mantiene in locale sul dispositivo tutti i dati inseriti e mette a disposizione
 un insieme di funzioni utili per la gestione del database.
\end_layout

\begin_layout Standard
La sezione per la gestione del proprio account e delle funzioni di autenticazion
e sono inserite in una parte del menù laterale della pagina principale dell'appl
icazione, permettendo di verificare se si è effettuato o meno l'accesso
 rapidamente.
 Si è inserito un header all'interno del menù laterale in cui sono visibili
 un'immagine circolare, un messaggio di benvenuto e un bottone per eseguire
 l'accesso.
 Una volta che l'utente sarà autenticato saranno invece visibili l'avatar,
 il nome, un'icona per accedere alla schermata di modifica dell'account
 e il bottone per eseguire il logout.
\end_layout

\begin_layout Standard
Si è poi implementata un'unica schermata dalla quale si può accedere al
 login tramite credenziali personali, al login tramite social network, alla
 registrazione di un nuovo account e si verrà reindirizzati a questa sezione
 ogni volta che l'utente tenterà di eseguire delle azioni in cui è necessario
 aver eseguito l'accesso senza essere autenticato.
\end_layout

\begin_layout Standard
Ogni azione che si vuole compiere, come per esempio l'accesso tramite credenzial
i, deve essere gestito all'interno dell'applicazione in modo molto accurato.
 Ogni campo di input è stato gestito in modo da attuare una validazione
 anche lato client informando in maniera diretta l'utente nel caso in cui
 i dati inseriti non siano corretti.
 A seguito dell'invio di ogni form viene eseguita una chiamata alle API
 del backend tramite l'interfaccia di supporto 
\emph on
Network
\emph default
 implementata in modo che ritorni eventuali messaggi di errore in maniera
 standardizzata.
\end_layout

\begin_layout Standard
Nel momento in cui l'utente esegue il login vengono aggiornate sul device
 le informazioni legate all'account, creando un oggetto Realm partendo dal
 modello, incapsulando ogni informazione scaricata dal server così che ogni
 sezione dell'applicativo possa accedervi localmente.
 L'accesso permette inoltre di accedere ad alcune sezioni dell'applicazione
 che altrimenti non si potrebbero visualizzare poichè ogni chiamata alle
 API deve essere corredata delle informazioni legate all'utente che esegue
 una determinata azione.
\end_layout

\begin_layout Standard
Infine anche le funzioni di logout sono gestite all'interno di un helper
 che incapsula tutte le operazioni necessarie per far si che nessun dato
 sensibile rimanga salvato in locale a seguite della disconessione dell'account
 e non vi siano casi di incosistenza tra le informazioni presenti in locale
 e sul server.
\end_layout

\begin_layout Section
Shop
\end_layout

\begin_layout Standard
Ogni gelateria inserita all'interno del circutio MyGelato è formalizzata
 concettualmente come un oggetto 
\emph on
Shop
\emph default
 che incapsula tutte le informazioni che il server rende leggibili per il
 download di volta in volta: identificativo, nome, indirizzo, recapito telefonic
o e ogni dato disponibile.
\end_layout

\begin_layout Standard
La gestione e il salvataggio in locale degli Shop all'interno dell'applicazione
 è stato necessario poichè in molti casi dati devono poter essere accessibili
 anche offline per quanto riguarda le operazioni che non richiedono un collegame
nto istantaneo con il backend, come per esempio la visualizzazione dei preferiti.
 Il download delle informazioni sul device avviene all'interno della schermata
 della Ricerca e avviene in background poichè avviata in maniera asincrona,
 a causa della grossa mole di dati da dover scaricare.
\end_layout

\begin_layout Standard
È stato quindi creato un modello per l'oggetto Shop sempre derivante da
 un oggetto Realm così da sfruttare tutta la potenza della libreria per
 il salvataggio e la gestione dei dati in database.
 Ad ogni ricerca le gelaterie vengono nuovamente scaricate così da avere
 sempre tutte le informazioni aggiornate, creando però un collo di bottiglia
 in termini di prestazioni che verrà spiegato e gestito nel dettaglio nel
 capitolo successivo.
\end_layout

\begin_layout Section
Ricerca
\end_layout

\begin_layout Section
Marketing Digitale
\end_layout

\begin_layout Standard
Il primo flusso logico principale ad essere stato implementato è stato quello
 del marketing digitale poichè legato solo in parte alla presenza di un
 utente registrato e autenticato all'applicazione; sono quindi presenti
 alcune operazioni comunque disponibili anche senza aver eseguito il login.
\end_layout

\begin_layout Standard
La prima sezione ad essere implementata è stata quella legata alla visualizzazio
ni delle carte del Mastro Gelatiere poichè il numero delle promozioni disponibil
i era da visualizzare anche all'interno della navigazione principale e quindi
 la richiesta per scaricarle doveva essere presente anche all'interno della
 schermata iniziale dell'applicazione.
\end_layout

\begin_layout Standard
Per ottenere un maggiore riutilizzo del codice si è scelto di creare una
 stessa sezione per visualizzare sia le carte del mastro gelatiere sia quelle
 delle singole gelaterie ottenendo una visualizzazione differente in base
 al collegamento (
\emph on
Intent
\emph default
) che avrebbe portato l'utente all'interno della sezione.
 Allo stesso modo si è utilizzato uno stesso modello per entrambe le carte
 definendo un elemento Realm di nome 
\emph on
Card
\emph default
 che incapsula i dati necessari all'utilizzo delle carte nel sistema differenzia
ndole grazie ad un flag presente anche nel modello fornito dal backend.
\end_layout

\begin_layout Standard
Avendo quindi implementato la visualizzazione delle carte scaricate tramite
 chiamata alle API, nella schermata appena descritta, è stato semplice eseguire
 il passaggio successivo che dalla visualizzazione della singola gelateria
 portava alle proprie carte promozionali: all'interno della finestra informativa
 con i dati dello shop all'interno della ricerca si sono inserite un'icona
 che funge da collegamento alle carte un'icona per aggiungere ai preferiti
 il singolo esercizio.
\end_layout

\begin_layout Standard
Per il salvataggio offline dei preferiti si è però dovuto creare un secondo
 modello all'interno del database 
\emph on
Favorite
\emph default
 che semplicemente identifica gli esercizi salvati tra i preferiti in modo
 che queste informazioni rimangano salvate in locale sul dispositivo anche
 senza che un utente che si sia loggato.
 L'inserimento di un flag all'interno del modello degli shop non avrebbe
 funzionato poichè sarebbe stato sovrascritto ad ogni aggiornamento degli
 shop durante il download e la modifica con le informazioni sul server.
\end_layout

\begin_layout Standard
Una volta che una gelateria viene aggiunta ai preferiti, nel caso l'utente
 si sia autenticato verrà eseguita una chiamata al server che attiverà la
 ricezione di notifiche push e in automatico verrà anche aggiunto un controllo
 per il geofencing sul dispositivo, entrambe le funzioni sono spiegate nel
 dettaglio nel capitolo 4.6.2.
\end_layout

\begin_layout Subsection
Carte Promozionali
\end_layout

\begin_layout Standard
L'implementazione delle carte promozionali ha seguito uno sviluppo volto
 ad utilizzare lo stesso codice e le stesse visualizzazioni sia per la la
 presentazione delle carte legate al singolo esercizio sia per quelle del
 mastro gelataio.
 Prima di tutto si è quindi realizzato il modello in Realm chiamato 
\emph on
Card
\emph default
 contenente le principali informazioni legate alla carta: identfiicativo,
 titolo, immagine, descrizione, eventuale link e recapito teleofonico.
\end_layout

\begin_layout Standard
È stata creata una schermata unica per la visualizzazione delle carte affiancate
, grazie all'utilizzo di un 
\emph on
ViewPager
\emph default
, con un layout elaborato dove ogni carta mostra la propria immagine e al
 click su un'icona in basso a destra ruota su se stessa per permettere di
 leggere la descrizione ed eventualmente ottenere nuove informazioni tramite
 il link proposto.
 Nel caso vi sia la presenza di un video il tap sull'immagine porterà alla
 visualizzazione online della risorsa resa disponibile tramite url.
\end_layout

\begin_layout Standard
Il download delle informazioni deve avvenire all'apertura della schermata
 grazie ad una richiesta alle API in background così da non bloccare il
 dispositivo dell'utente.
 Tutti i dati scaricati vengono salvati in locale così da essere disponibili
 anche offline e nel caso di modifiche saranno aggiornati eliminando anche
 le promozioni non più disponbili perchè scadute.
\end_layout

\begin_layout Standard
Nel caso delle carte del mastro gelatiere il procedimento di richiesta dei
 dati deve essere eseguito anche all'interno della schermata principale
 poichè il numero delle carte è da visualizzare all'interno dell'immagine
 del menù che rimanda alla sezione del mastro gelatiere.
 Inoltre nel caso di un utente con autenticazione effettuata verrà registrato
 il dispositivo sul server per la ricezione di una notifica push ogni volta
 che sarano pubblicate nuove promozioni.
\end_layout

\begin_layout Subsection
Preferiti
\end_layout

\begin_layout Standard
Il primo sviluppo legato alla sezione dei preferiti è stata quella della
 gestione dell'aggiunta e della rimozione all'interno della visualizzazione
 della ricerca in cui tramite un'icona l'utente può salvare localmente le
 sue preferenze.
 Successivamente si è implementata la sezione dell'applicazione che permette
 la visualizzazione e la gestione della lista degli esercizi preferiti,
 direttamente raggiungibile dalla navigazione principale.
\end_layout

\begin_layout Standard
Avendo gestito l'aggiunta e la rimozione dei preferiti grazie ad un sistema
 centralizzato che racchiudeva tutte le operazioni necessarie è stato abbastanza
 intuitivo poter inserire un middleware che gestisse l'aggiunta e la rimozione
 delle funzionalità riguardanti l'iscrizione alle notifiche push ricevute
 del server e del geofencing gestito dal dispositivo.
\end_layout

\begin_layout Standard
L'utente può aggiungere una gelateria ai preferiti cliccando sull'icona
 della stella presente nella finestra di informazioni visualizzata all'interno
 della ricerca degli shop una volta selezionatone uno.
 L'aggiunta, come anche la rimozione, aggiorna immediatamente sia la mappa
 modificando il marker mostrato a video e anche la lista dei preferiti.
\end_layout

\begin_layout Standard
Per l'implementazione della funzinalità di notifiche push si è scelto di
 utilizzare i servizi resi disponibili da Google stessa utilizzando inizialmente
 
\emph on
Google Cloud Messaging
\emph default
 per poi passare ad utilizzare il servizio 
\emph on
Firebase
\emph default
, nuovo applicativo appena reso disponbile e sicuramente più innovativo
 e aggiornato.
 Per far dialogare in maniera bidirezionale l'applicativo e il server nel
 momento in cui un utente esegue il login all'applicazione viene attivato
 Firebase richiedendo al server un token che verrà poi passato al sistema
 di gestione delle notifiche che si metterà in ascolto.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

FirebaseApp.initializeApp(
\end_layout

\begin_layout Plain Layout

    this,
\end_layout

\begin_layout Plain Layout

    FirebaseOptions.fromResource(this)
\end_layout

\begin_layout Plain Layout

);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Ogni volta che l'utente aggiungerà e rimuoverà un preferito verrà quindi
 eseguita una chiamata al backend con lo scopo di informarlo della modifca
 attivando o disattivando rispettivamente la ricezione delle notifiche push.
 In questo modo nel momento in cui sarà disponibile una nuova carta promozionale
 per quello schop verrà visualizzata una notifica sul device che permetterà
 all'utente di accedere direttamente alla sezione delle carte promozionali
 specifiche per quell'esercizio.
\end_layout

\begin_layout Standard
Allo stesso tempo, solo a livello applicativo verrà inoltre sottoscritto
 al sistema una richiesta di geofencing che produrrà un 
\emph on
Intent
\emph default
 ogni qual volta l'utente rimarrà entro l'area di 5 kilometri da una gelateria
 presente tra i preferiti, il quale verrà gestito per mostrare anche in
 questo caso una notifica che permetterà di accedere invece alle informazioni
 della gelateria all'interno della lista dei preferiti.
 Ovviamente per i dispositivi con le ultime versioni di Android sarà necessario
 richiedere anche in questo caso la possibilità di accedere alla localizzazione
 come fatto all'interno della ricerca.
\end_layout

\begin_layout Standard
Nello snippet di codice si può vedere come l'applicazione si registra al
 servizio di Geofencing del sistema una volta che una gelateria 
\emph on
shop
\emph default
 viene inserito tra i preferiti.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

mGeofenceList.add(new
\end_layout

\begin_layout Plain Layout

    Geofence.Builder()  
\end_layout

\begin_layout Plain Layout

      .setCircularRegion(                                             
\end_layout

\begin_layout Plain Layout

         shop.latitude,                                             
\end_layout

\begin_layout Plain Layout

         shop.longitude,                                             
\end_layout

\begin_layout Plain Layout

         GEOFENCE_RADIUS_IN_METERS                                     
\end_layout

\begin_layout Plain Layout

      )                                     
\end_layout

\begin_layout Plain Layout

      .setLoiteringDelay(2 * 60 * 1000)                                 
    
\end_layout

\begin_layout Plain Layout

      .setTransitionTypes(Geofence.GEOFENCE_TRANSITION_DWELL)            
                         
\end_layout

\begin_layout Plain Layout

      .build()
\end_layout

\begin_layout Plain Layout

);
\end_layout

\end_inset


\end_layout

\begin_layout Section
E-Commerce
\end_layout

\begin_layout Standard
Il sistema di e-commerce è stato l'ultimo tassello dell'applicazione che
 ha concluso il lavoro di sviluppo diretto di questo elaborato.
 Si è trattato di unificare parte delle componenti già implementate creando
 un workflow che permetta all'utente di comprare e utilizzare i coupon digitali
 in sicurezza e con facilità.
\end_layout

\begin_layout Standard
La prima fase è stata legata alla rappresentazione formale dei buoni salvati
 sul server legati ad un determinato account e dei buoni disponibili all'acquist
o legati invece ad una determinata gelateria, in particolare è stato importante
 valutare quali informazioni mantenere sempre in locale per non inficiare
 la consistenza dei dati presenti sul dispositivo rispetto a quelli online.
\end_layout

\begin_layout Standard
Definita la struttura degli elementi che si sarebbero andati ad utilizzare
 si è creata la sezione dedicata alla gestione dei coupon personali disponibili
 ad ogni utente, ovviamente legado ogni funzione alla necessaria autenticazione
 tramite account iscritto all'applicazione MyGelato.
 Questa sezione permette di avere una visione completa delle proprie informazion
i aggiornate poichè vi è un forte legame con i dati presenti sul server
 online, infatti molte delle funzioni legate al sistema di e-commerce comprendon
o l'utilizzo di account e dispositivi diversi che interagiscono e che non
 devono assolutamente creare casi di incosistenza.
\end_layout

\begin_layout Standard
Per rendere accessibile all'utente l'accesso alle funzioni di acquisto e
 di riscatto di un buono in maniera diretta si sono inseriti all'interno
 della navigazione principale dell'applicazione i collegamenti a queste
 sezioni insieme ad un bottone flottante che riporta alla gestione dei coupon;
 nel caso si sia effettuato l'accesso con un account di tipo gelatiere si
 verrà riportati invece alla sezione per la validazione dei buoni.
\end_layout

\begin_layout Subsection
Coupon
\end_layout

\begin_layout Standard
Per formalizzare il concetto di coupon personale di ogni utente si è scelto
 di creare una classe 
\emph on
Coupon
\emph default
, estensione di un modello Realm, che incapsula tutte le informazioni disponibil
i: identificativo, nome, gelateria di riferimento, acquirente, ecc...
 Sfruttando Realm le operazioni di gestione e salvataggio sul database sono
 particolamente semplificate ed è essenziale che venga assicurata un'alta
 sicurezza nella gestione.
\end_layout

\begin_layout Standard
Ogni coupon è unico grazie a un identificativo personale, possiede alcune
 informazioni importanti come l'acquirente e l'attuale propietario, la data
 di vendita e anche alcune informazioni non direttamente utili all'utilizzo
 tramite applicativo.
 Ogni dato viene salvato sul server e richiesto tramite una chiamata alle
 API quando si utilizza la sezione per la gestione dei buoni.
 
\end_layout

\begin_layout Standard
Dentro questa sezione sono presenti tre elenchi in cui sono visibili i coupon
 validi (utilizzabili e condivisibili), ricevuti da altri utenti, e la lista
 completa di tutti buoni legati all'utente.
 Come si può vedere in figura 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Coupon"

\end_inset

, ogni coupon visualizza alcune informazioni di base e sono presenti i collegame
nti diretti per l'utilizzo e lo share tramite altri canali di comunicazioni.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Coupon"

\end_inset

Coupon
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Acquisto
\end_layout

\begin_layout Subsection
Condivisione e Riscatto
\end_layout

\begin_layout Standard
Il meccanismo di condivisione e riscatto ha coinvolto funzioni complementari
 che dovevano sfruttare anche componenti a livello di sistema operativo.
 Per permettere il dialogo tra due dispositivi differenti si è scelto di
 sfruttare i canali di comunicazioni più comuni e diffusi anche tra gli
 utenti medi in modo che il sistema di share sia il più facile possibile
 e del tutto conforme al sistema di condivisione standard della piattaforma.
\end_layout

\begin_layout Standard
Dalla lista di coupon disponibili l'utente ha la possibilità di cliccare
 sull'icona per la condivisone e verrà inviata una richiesta - 
\emph on
Intent
\emph default
 - a livello di sistema in broadcast per poter selezionare il metodo che
 si preferisce per inviare un testo precompilato insieme ad un link.
 Il testo presenta brevemente l'oggetto della condivisione e invita ad utilizzar
e il link per riscattare il coupon specificato.
\end_layout

\begin_layout Standard
Il link riporta a una pagina resa disponibile dal backend che riconosce
 il sistema operativo dal quale ci sis sta collegando per effettuare un
 redirect ad un link particolare che verrà gestito in automatico dal device
 con cui si sta visualizzando il sito.
 Nel caso in cui vi sia installata sul device l'applicazione MyGelato allorà
 verrà avviata la schermata di riscatto precompilata con i dati necessari,
 altrimenti si verrà reindirizzati agli store principali per consigliare
 il download dell'applicazione.
\end_layout

\begin_layout Standard
Il mezzo per permettere l'identificazione del coupon da condividere è un
 codice alfanumerico a sei cifre, il PNR, che viene condiviso in automatico
 insieme al resto delle informazioni.
 All'interno della schermata di riscatto di un buono, raggiungibile dirattamente
 dalla navigazione princiapale dell'app è necessario inserire il codice
 del buono che si vuole riscattare.
 Come detto nel caso si arrivi sulla schermata tramite il link condiviso
 allora il campo di input del codice sarà precompilato.
\end_layout

\begin_layout Standard
Una volta inserito il codice, che verrà validato al momento con dei controlli
 basilari, sarà effettuata una richiesta al server tramite chiamata API
 che attuerà lo spostamento del buono da un utente all'altro.
 Per entrambi gli account vi sarà quindi l'aggiormento delle informazioni
 sul proprio dispositivo la prima volta che verranno richiesti i coupon
 disponibili.
\end_layout

\begin_layout Standard
L'utente che ha effettuato il riscatto verrà immediatamente reindirizzato
 sulla schermata di lista dei coupon nel caso in cui il processo sia andato
 a buon fine, altrimenti verrà notificato con un messaggio di errore.
 La figura 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Condivisione-e-Riscatto"

\end_inset

 mostra tutti i passaggi principali per la condivisione e il riscatto di
 un buono.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Condivisione-e-Riscatto"

\end_inset

Condivisione e Riscatto
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Utilizzo e Validazione
\end_layout

\begin_layout Standard
L'ultimo passaggio del workflow di e-commerce è l'utilizzo dei coupon che
 si sono acquistati o che si hanno riscattato perchè condivisi da altri
 utenti.
 In questo processo entrato in gioco due entità che sono utenti che spesso
 non entrano in contatto se non solo per i pochi momenti che servono all'acquist
o materiale del valore del buono utilizzato.
 Questa situazione pone alcune limitazioni negli strumenti utilizzati per
 la comunicazione tra i due dispositivi che devono collaborare mantenendo
 uno stato costantemente consistente sia sui device fisici che sul server.
\end_layout

\begin_layout Standard
Per superare questo ostacolo si è scelto uno strumento molto diffuso che
 è l'utilizzo di QR code che permette di generare un'immagine a partire
 da un testo, in questo caso il PNR code lagato al coupon che si vuole utilizzar
e, leggibile ed interpretabile da un qualsiasi cellulare con un fotocamera.
 Chiunque abbia effettuato l'accesso all'applicazione con account di tipo
 gelatiere potrà validare il coupon direttamente tramite l'applicazione
 MyGelato grazie a una chiamata API al backend che confermerà o meno l'avvenuta
 conclusione del processo senza problemi.
\end_layout

\begin_layout Standard
La sezione per generare e visualizzare il codice QR da mostrare in gelateria
 è raggungibile cliccando sul singolo coupon all'interno della gestione
 dei propri buoni.
 Non essendo presente in questo caso una connessione bidirezionale con il
 backend, per aggiornare la schermata una volta concluso il processo di
 utilizzo l'applicazione effettua un polling al server ogni cinque secondi
 per verificare se il coupon sia stato utilizzato o meno.
\end_layout

\begin_layout Standard
Chiunque possieda un account di tipo gelatiere avrà nella navigazione principale
 dell'applicativo il collegamento alla sezione per la convalida.
 Verrà avviata immediatamente la fotocamera che, tramite una libreria esterna,
 verificherà la presenza o meno di codici QR leggendoli.
 Dopo una validazione semplice si effettettuerà la chiamata al server dando
 poi la possibilità di convalidare altri coupon senza dover ritornare ogni
 volta alla schermata iniziale.
 Nel caso in cui la fotocamera sia già occupata da altri processi attivi
 sul dispositivo o nel caso in cui l'utente abbia rimosso alcuni permessi
 all'applicativo verrà visualizzato un messaggio di errore che comunicherà
 al proprietario del device cosa fare per risolvere il problema.
\end_layout

\begin_layout Standard
A conclusione del processo di validazione di un coupon entrambi i dispositivi
 verranno aggiornati per mantenere coerenza tra i dati presenti sul sistema
 risolvendo così in maniera semplice il problema principale del dialogo
 tra due dispositivi rendendo l'utilizzo di un buono molto semplice sempre
 basandosi sul fatto che ormai uno smartphone sia diventato un bene comune.
 La figura 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Acquisto"

\end_inset

 permette di visualizzare i passaggi fondamentali per l'utilizzo e la validazion
e di un buono.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Acquisto"

\end_inset

Acquisto
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\end_body
\end_document
