#LyX 2.2 created this file. For more info see http://www.lyx.org/
\lyxformat 508
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass extreport
\options openright,cleardoublepage=empty
\use_default_options false
\maintain_unincluded_children false
\language italian
\language_package default
\inputencoding utf8
\fontencoding T1
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize 12
\spacing single
\use_hyperref true
\pdf_bookmarks false
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder false
\pdf_colorlinks false
\pdf_backref section
\pdf_pdfusetitle false
\pdf_quoted_options "colorlinks,citecolor=black,filecolor=black,linkcolor=black,urlcolor=black"
\papersize a4paper
\use_geometry true
\use_package amsmath 1
\use_package amssymb 0
\use_package cancel 0
\use_package esint 1
\use_package mathdots 0
\use_package mathtools 0
\use_package mhchem 0
\use_package stackrel 0
\use_package stmaryrd 0
\use_package undertilde 0
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language french
\papercolumns 1
\papersides 2
\paperpagestyle fancy
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
Progettazione
\end_layout

\begin_layout Standard
Definiti gli obiettivi progettuali dell'applicazione si sono valutati gli
 strumenti di sviluppo da utilizzare durante lo svolgimento della tesi:
 come parametri si é tenuto conto di tempistiche di aggiornamento, adeguamento
 alle linee guida del sistema operativo in oggetto, documentazione disponibile
 e modernità delle tecnologie utilizzate.
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Durante la prima fase di sviluppo strutturale si sono valutate le tecnologie
 da utilizzare in modo da tenere il passo con le ultime specifiche di Android
 e tenendo conto che, anche secondo gli ultimi report pubblicati da Google,
 rimane una forte frammentazione della distribuzione del sistema operativo,
 dovuta ai molteplici vendor.
 
\begin_inset CommandInset citation
LatexCommand cite
key "ANDROIDSTUDIO:DASHBOARD"

\end_inset

 È quindi da tenere in considerazione la retrocompatibilità delle librerie
 utilizzate, avendo scelto di supportare fino alla versione 16 del SDK di
 Android (versione 4.1 Jelly Bean), e la possibilità di utilizzare l'applicazione
 anche su dispositivi con schermi e hardware differenti.
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Considerato infine che alcuni nodi centrali dell'elaborato necessitano di
 specifiche minime in termini di affidabilità e sicurezza si è scelto di
 utilizzare librerie esterne anche per le funzioni di utilizzo del database
 e di connessione al server, rispettivamente Realm e OkHttp, che oltre a
 semplificare lo sviluppo garantiscono un'alta gestione degli errori.
\end_layout

\begin_layout Section
Sviluppo Android
\end_layout

\begin_layout Standard
Questa tesi si inserisce all'interno del lavoro di creazione della piattaforma
 MyGelato, il quale include il supporto sia alla piattaforma Android sia
 alla piattaforma iOS.
 Essendosi però creati due differenti progetti durante la prima fase di
 progettazione, si è potuto scegliere come metodo implementativo l'utilizzo
 della programmazione nativa Android che si basa su Java per la programmazione
 e su XML per la creazione delle risorse.
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Sicuramente lavorare in questo modo ha i propri pro e contro: mentre da
 un lato il nativo offre la possibilità di una gestione totale del dispositivo
 senza la paura di trovare limiti, d’altra parte richiede spesso una programmazi
one molto professionale e si concentra esclusivamente su una piattaforma
 impedendo un’agile riciclo dei propri sforzi su altri mercati del mobile.
 Il non-nativo, invece, offre diversi vantaggi ascrivibili alla necessità
 di creare applicazioni cross-platform distribuibili su sistemi operativi
 diversi.
 
\begin_inset CommandInset citation
LatexCommand cite
key "HTMLIT:PROG_NATIVA"

\end_inset

 Non avendo quindi necessità di mantenere alta la portabilità del codice
 su altre piattaforme, si è preferito sviluppare tramite programmazione
 nativa; potendo quindi sfruttare pienamente l'architettura del sistema
 operativo sottostante e gli strumenti di sviluppo forniti ufficialmente.
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Si è scelto quindi di utilizzare come principale strumento 
\emph on
Android Studio
\emph default
, Integrated Development Environment (IDE) dedicato alla programmazione
 Android distribuito da JetBrains e Google che è ormai il miglior software
 per la creazione dei applicazioni su questa piattaforma.
 
\begin_inset CommandInset citation
LatexCommand cite
key "ANDROIDDEVELOPERS:FIRSTAPP"

\end_inset


\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Durante lo sviluppo del progetto si è utilizzato come sistema di versioning
 il software 
\series bold
Git
\series default
, così da poter mantenere uno storico del lavoro svolto e ottenendo tutti
 i vantaggi dell'utilizzo di un Sistema per il Controllo di Versione (
\shape italic
Version Control System - VCS
\shape default
), mentre per il test delle chiamate al backend della piattaforma si è utilizzat
a la web application Postman 
\begin_inset CommandInset citation
LatexCommand cite
key "POSTMAN"

\end_inset

 che permette di testare e sviluppare le API con cui due applicativi possono
 dialogare.
\end_layout

\begin_layout Subsection
Programmazione Nativa
\end_layout

\begin_layout Standard
Le applicazioni Android sono sviluppate utilizzando il linguaggio Java.
 È un linguaggio di programmazione molto popolare sviluppato da Sun Microsystems
 (ora di proprietà di Oracle) orientato agli oggetti a tipizzazione statica,
 specificatamente progettato per essere il più possibile indipendente dalla
 piattaforma di esecuzione.
 
\begin_inset CommandInset citation
LatexCommand cite
key "WIKIPEDIA:JAVA"

\end_inset


\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Per lo sviluppo di un applicativo si devono sfruttare le principali caratteristi
che di Java andando a estendere, per ogni schermata che si vuole creare,
 la classe 
\emph on
Activity 
\emph default
implementata come standard all'interno delle libreria Android.
 Qualsiasi progetto sarà quindi formato da un insieme di classi che rappresenter
anno logicamente ogni singola schermata unite ad altre classi che incapsuleranno
 invece le funzioni, i modelli e ogni altro componente standard di Android.All'in
terno dell'ultima distribuzione di Android sono state incluse alcune delle
 funzionalità di Java 8, ma l'alta frammentazione della piattaforma non
 ne permette correttamente l'utilizzo.
 Questo si ripercuote su alcune funzionalità come le chiamate http che non
 supportano alcune delle semplificazioni che sono state fatte ad esempio
 nelle connessioni sicure grazie a TLS.
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Come si può vedere all'interno del listato la classe 
\emph on
Main
\emph default
 estende la classe 
\emph on
AppCompatActivity 
\emph default
e dopo aver richiamato il costruttore della propria superclasse esegue la
 creazione dell'interfaccia utente grazie al file di layout 
\emph on
activity_main
\emph default
 che ne specifica la struttura e le impostazioni, scritto in XML.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public class Main extends AppCompatActivity {
\end_layout

\begin_layout Plain Layout

    @Override
\end_layout

\begin_layout Plain Layout

    protected void onCreate(Bundle savedInstanceState) {
\end_layout

\begin_layout Plain Layout

        super.onCreate(savedInstanceState);
\end_layout

\begin_layout Plain Layout

        setContentView(R.layout.activity_main);
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    ...
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lis:AppCompatActivity"

\end_inset

AppCompatActivity
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
XML (sigla di eXtensible Markup Language) è un metalinguaggio per la definizione
 di linguaggi di markup, ovvero un linguaggio marcatore basato su un meccanismo
 sintattico che consente di definire e controllare il significato degli
 elementi contenuti in un documento o in un testo.
 All'interno dello sviluppo di applicazioni Android rappresenta il linguaggio
 per la creazione delle risorse: layout, manifest, ecc...
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
L'esempio più eclatante è l'utilizzo dell'XML per produrre il manifesto
 dell'applicazione, che ne rappresenta ed espone la struttura principale
 dichiarando ogni singola schermata o servizio presenti specificando anche
 il tema da utilizzare, il nome e alcune opzioni di avvio.
 Sono scritte in XML anche tutte le risorse interne all'applicazione come
 si può notare nell'esempio di codice sottostante che descrive una schermata
 con una singola immagine.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

<?xml version="1.0" encoding="utf-8"?>
\end_layout

\begin_layout Plain Layout

<LinearLayout
\end_layout

\begin_layout Plain Layout

    xmlns:android="http://schemas.android.com/apk/res/android"
\end_layout

\begin_layout Plain Layout

    android:layout_width="match_parent"
\end_layout

\begin_layout Plain Layout

    android:layout_height="match_parent">
\end_layout

\begin_layout Plain Layout

    <ImageView
\end_layout

\begin_layout Plain Layout

         android:layout_width="wrap_content"
\end_layout

\begin_layout Plain Layout

         android:layout_height="wrap_content"
\end_layout

\begin_layout Plain Layout

         src="drawable/icon" />
\end_layout

\begin_layout Plain Layout

</LinearLayout>
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Layout XML
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Android Studio
\end_layout

\begin_layout Standard
Android Studio 
\begin_inset CommandInset citation
LatexCommand cite
key "WIKIPEDIA:ANDROIDSTUDIO"

\end_inset

 è un ambiente di sviluppo integrato (IDE) per lo sviluppo per la piattaforma
 Android.
 È stato annunciato il 16 maggio 2013 in occasione della conferenza Google
 I/O e la prima build stabile fu rilasciata nel dicembre del 2014.
 Basato sul software della JetBrains, Android Studio è stato progettato
 specificamente per lo sviluppo di Android.
 Sostituisce gli Android Development Tools (ADT) di Eclipse, diventando
 l' IDE primario di Google per lo sviluppo nativo di applicazioni Android
 offre ancora più funzioni che migliorano la produttività durante la creazione
 di applicazioni Android, come ad esempio: un sistema di compilazione Gradle,
 un ambiente unificato dove è possibile sviluppare per tutti i dispositivi,
 esecuzione e costruzione di un file APK per la pubblicazione di una applicazion
e sui canali di distribuzione più importanti e l'integrazione GitHub.
\end_layout

\begin_layout Standard
Ogni progetto creato all'interno del software contiene alcuni moduli principali
 che riguardano l'applicazione vera e propria, le librerie incluse e i moduli
 proprietari di Google che permettono l'utilizzo dei suoi servizi principali
 come Firebase e le Google Maps API.
 
\begin_inset CommandInset citation
LatexCommand cite
key "GOOGLE:MAPS_API"

\end_inset


\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
A livello di build del sistema si trova uno script Gradle
\begin_inset CommandInset citation
LatexCommand cite
key "GRADLE"

\end_inset

 che a partire da un manifesto, che dichiara la struttura dell'applicazione,
 i file Java contenenti il codice sorgente (inclusi i test) e l'insieme
 delle risorse e degli asset può generare un file firmato installabile su
 qualsiasi dispositivo.
\end_layout

\begin_layout Standard
Per la generazione delle risorse Android Studio mette a disposizione alcuni
 tool, tra cui alcuni grafici, che permettono l'implementazione e il test
 dell'interfaccia utente senza dover di volta in volta avviare l'applicativo
 su un emulatore, messo a disposizione dal sofwtare stesso, o su un dispositivo
 fisico.
\end_layout

\begin_layout Standard
Ovviamente AS incapsula tutti i tool utili alla programmazione come la formattaz
ione, lo stile e la correzione in realtime del codice scritto effettuando
 il controllo sintattico e l'analisi statica seguendo i pattern standard
 della piattaforma.
\end_layout

\begin_layout Subsection
Git
\end_layout

\begin_layout Standard
Git è un software di controllo versione distribuito (
\shape italic
Distributed Version Control Systems - DVCS
\shape default
) utilizzabile da interfaccia a riga di comando, creato da Linus Torvalds
 nel 2005.
 
\begin_inset CommandInset citation
LatexCommand cite
key "WIKIPEDIA:GIT"

\end_inset

 Nacque per essere un semplice strumento per facilitare lo sviluppo del
 kernel Linux ed è diventato uno degli strumenti di controllo versione più
 diffusi.
\end_layout

\begin_layout Standard
Per quanto riguarda qualsiasi tipo di progetto di IT (
\shape italic
Information Technology
\shape default
), specialmente se si tratta di un lavoro da dover svolgere in team, Git
 dà la possibilità di mantenere in memoria tutte le versioni del proprio
 lavoro (sia in locale che online).
 Questo permette a più persone di poter accedere alla cronologia del lavoro
 condiviso, avendo anche la possibilità di verificare la presenza di errori
 e di eliminarli tornando a una versione precedente del progetto.
 Git sfrutta alcuni algoritmi avanzati per calcolare le differenze riga
 per riga tra i file di diverse versioni così da verificare la presenza
 di errori o conflitti.
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Git è fortemente direzionato verso uno sviluppo progettuale non lineare.
 Supporta diramazione e fusione (
\shape italic
branching and merging
\shape default
) rapide e comode, e comprende strumenti specifici per visualizzare e navigare
 l'intero storico delle versioni anche se proposte da sistemi differenti.
 È veloce e scalabile nella gestione di grandi progetti ed è molto utile
 nello sviluppo in team, specialmente se affiancato dal modello GitFlow
 che permette di gestire rami specifici per il developing o per le release.
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Infine grazie all'utilizzo di piccoli accorgimenti come il file .gitignore
 (che permette di non salvare anche i file temporanei e non importanti del
 progetto) e soluzioni online come GitHub o BitBucket (quest'ultimo utilizzato
 durante lo sviluppo di questa tesi) il processo di sviluppo software viene
 drasticamente avvantaggiato.
\end_layout

\begin_layout Section
Database
\end_layout

\begin_layout Standard
La piattaforma Android fornisce diversi metodi e strumenti per salvare i
 dati delle applicazioni in modo persistente.
 Per quanto riguarda le preferenze relative alle impostazioni dell'applicazione
 si possono implementare le 
\emph on
Shared Preferences 
\emph default
per salvare le scelte dell'utente; mentre per quanto riguarda la memorizzazione
 persistente di una grossa mole di dati si possono utilizzare strumenti
 come l'
\emph on
Internal Storage
\emph default
 o un 
\emph on
Database SQLite
\emph default
.
 
\begin_inset CommandInset citation
LatexCommand cite
key "HTMLIT:DB"

\end_inset


\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Esistono però anche alternativa agli strumenti standard forniti ufficialmente
 per la piattaforma e uno di questi è la libreria 
\emph on
Realm
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "REALM"

\end_inset

: database object-oriented che non incapsula SQLite ma lo sostituisce con
 un sistema di memorizzazione scritto in C++ che permette l'accesso ai dati
 anche tramite l'utilizzo di linguaggi di programmazione differenti.
 Modifica inoltre il metodo di accesso ai dati salvati non richiedendo query
 esplicite integrando molte delle funzionalità dei sistemi basati su l'
\emph on
Object-Relational Mapping (ORM)
\emph default
, semplificando di gran lunga l'utilizzo del database durante lo sviluppo
 di qualsiasi applicazione.
\end_layout

\begin_layout Subsection
Realm
\end_layout

\begin_layout Standard
La prima configurazione per l'utilizzo di Realm è rintracciabile nella creazione
 di una semplice dipendenza all'interno dei file 
\emph on
Gradle
\emph default
 (tool di Andriod Studio per il compile, il deploy e la gestione delle dipendenz
e) dove va inserita l'ultima versione disponibile della libreria.
 È inoltre necessario inserire una prima inizializzazione all'interno dell'avvio
 dell'applicazione, andando quindi a estendere la classe 
\emph on
Application
\emph default
 esposta dalle libreria dell'SDK di Android.
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Una volta configurato il plugin si possono creare i modelli degli oggetti
 che saranno da salvare all'interno della base di dati, come per esempio
 un oggetto 
\emph on
Utente
\emph default
 rappresentato ad esempio dalla classe 
\emph on
User
\emph default
 come si può vedere nel listato 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Model-Realm"

\end_inset

 dove sono descritte le principali variabili che lo compongono, tra cui
 la chiave primaria denotata dalla keyword 
\emph on
PrimaryKey.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

import io.realm.RealmObject;
\end_layout

\begin_layout Plain Layout

import io.realm.annotations.PrimaryKey;
\end_layout

\begin_layout Plain Layout

public class User extends RealmObject {
\end_layout

\begin_layout Plain Layout

    @PrimaryKey
\end_layout

\begin_layout Plain Layout

    public String uuid;
\end_layout

\begin_layout Plain Layout

    public String firstName;
\end_layout

\begin_layout Plain Layout

    public String lastName;
\end_layout

\begin_layout Plain Layout

    public String email;
\end_layout

\begin_layout Plain Layout

    public User() {
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lis:Model-Realm"

\end_inset

Model Realm
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
L'utilizzo di questi modelli è molto semplificato poichè Realm permette
 di creare delle transizioni sui singoli oggetti creati così da poter aggiornare
 la loro versione contenuta all'interno del database, assicurando in ogni
 istante le proprietà ACID delle operazioni.
 
\begin_inset CommandInset citation
LatexCommand cite
key "WIKIPEDIA:ACID"

\end_inset

 Si può vedere nel seguente listato un esempio di creazione o aggiornamento
 di un oggetto user in base al fatto che sia o non sia già presente all'interno
 della base di dati.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Realm realm = Realm.getDefaultInstance();
\end_layout

\begin_layout Plain Layout

User user = new User(Params...);
\end_layout

\begin_layout Plain Layout

realm.executeTransaction(new Realm.Transaction() {
\end_layout

\begin_layout Plain Layout

      @Override
\end_layout

\begin_layout Plain Layout

      public void execute(Realm realm) {
\end_layout

\begin_layout Plain Layout

          realm.copyToRealmOrUpdate(user);
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

});
\end_layout

\begin_layout Plain Layout

realm.close();
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Realm Transaction
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Allo stesso modo con cui vengono semplificati gli inserimenti di dati all'intern
o del DB è forse fondamentale capire come vengono gestite anche le query
 sulla base di dati; Un esempio molto semplice visibile nel listato 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Realm-Query"

\end_inset

 mostra come sia possibile richiedere un utente con email non nulla all'interno
 dei dati salvati ottenendoli in un 
\emph on
ArrayList
\emph default
 utilizzabile direttamente per scorrere ogni singolo oggetto ottenuto dalla
 richiesta.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

RealmResults<User> results = 
\end_layout

\begin_layout Plain Layout

     Realm.getDefaultInstance()
\end_layout

\begin_layout Plain Layout

          .where(User.class)
\end_layout

\begin_layout Plain Layout

          .notNull("email")
\end_layout

\begin_layout Plain Layout

.findAll();
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lis:Realm-Query"

\end_inset

Realm Query
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Ultimo elemento da presentare della libreria Realm sono i 
\emph on
listener
\emph default
 che si possono attivare sia sull'intero database sia su una singola porzione
 in modo che eseguano una determinata callback nel momento in cui avviene
 una modificati dei dati monitorati.
 Un breve esempio è visualizzato nel codice seguente.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Realm realm = Realm.getDefaultInstance();
\end_layout

\begin_layout Plain Layout

realm.addChangeListener(new RealmChangeListener<Realm>() {
\end_layout

\begin_layout Plain Layout

      @Override
\end_layout

\begin_layout Plain Layout

      public void onChange(Realm element) {
\end_layout

\begin_layout Plain Layout

            // do something...
    
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

});
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Realm Listener
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Network Connection
\end_layout

\begin_layout Standard
Attualmente ogni tipo di piattaforma che voglia permettere al proprio utente
 di accedere da remoto, e quindi da qualsiasi dispositivo, alle proprie
 informazioni ha come parte fondamentale lo sviluppo e il mantenimento di
 un server di beckend (quindi nascosto nelle funzionalità alla vista dell'utente
) che mantenga, gestisca e restituisca i dati necessari alle funzioni degli
 applicativi.
 Nello stesso modo la piattaforma MyGelato si basa su un server che mantiene
 ogni informazione riguardante utenti, shop e card fornendo delle API REST
 che vengono sfruttate dalle applicazioni mobile e web per poter fornire
 i propri servizi.
 
\begin_inset CommandInset citation
LatexCommand cite
key "HTMLIT:REST"

\end_inset


\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Il passaggio di informazioni tra i due applicativi avviene tramite chiamate
 internet con protocollo Http protette grazie a una connessione criptata
 dal Transport Layer Security (TLS) o dal suo predecessore, Secure Sockets
 Layer (SSL).
 Grazie alla API REST è possibile seguire alcuni pattern delle tecnologie
 che permettono di valutare ogni possibile errore delle connessioni: errori
 nei dati, nella connessione, ecc...
 In Java le chiamate http sono difficilmente gestibili poichè non sono automatiz
zate e son stati effettuati dei cambiamenti nelle ultime versioni che non
 permettono di lavorare correttamente su tutti i dispositivi Android.
 Per questo motivo è stata utilizzata la libreria open-source OkHttp sviluppata
 da Square, che permette di automatizzare le chiamate http sfruttando anche
 una notevole semplificazione del codice utilizzato per programmare.
 
\begin_inset CommandInset citation
LatexCommand cite
key "SQUARE:OKHTTP"

\end_inset


\end_layout

\begin_layout Subsection
OkHttp
\end_layout

\begin_layout Standard
La liberia OkHttp nasce dal fatto che il protocollo http è l'attuale mezzo
 di comunicazione per ogni applicativo moderno.
 Per questo si pone l'obiettivo di semplificarne l'utilizzo e di migliorare
 le prestazioni delle tecnologie che lo sfruttano fornendo allo sviluppatore
 alcuni automatismi comodi durante la programmazione e l'implementazione.
\end_layout

\begin_layout Standard
Supporta ogni tipo di comunicazione http, ne gestisce la latenza, il caching,
 la riconnessione, l'utilizzo di protocolli sicuri come TLS, l'utilizzo
 di indirizzi IP multipli ed è molto semplice da integrare e utilizzare
 all'interno del proprio software.
 Grazie a un'interfaccia molto semplice permette di automatizzare le chiamate
 http utilizzando dei Builder che lasciano specificare solo i parametri
 necessari e restituiscono un unico oggetto da cui si ottiene la risposta,
 positiva o negativa, della richiesta.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

OkHttpClient client = new OkHttpClient();
\end_layout

\begin_layout Plain Layout

Request request = new Request.Builder()
\end_layout

\begin_layout Plain Layout

           .url(endpoint)
\end_layout

\begin_layout Plain Layout

           .addHeader("Accept","application/json")
\end_layout

\begin_layout Plain Layout

           .build();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Response response = client.newCall(request).execute();
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Network Connection
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Inizializzato il client OkHttp serve creare un oggetto 
\emph on
Request 
\emph default
a cui vanno passati i parametri necessari per poi eseguire la chiamata ottenendo
 infine un oggetto 
\emph on
Response 
\emph default
all'interno del quale sono presenti i dati scaricati, il codice di risposta
 della chiamata e anche eventuali errori.
\end_layout

\begin_layout Section
Gestore di Eventi
\end_layout

\begin_layout Standard
Un passaggio fondamentale durante lo sviluppo di un software è l'aggiornamento
 delle view a seguito di un cambiamento nello stato dell'applicazione.
 In Android è necessario intervenire direttamente sugli elementi dell'interfacci
a modificando ogni oggetto in base alle specifiche richieste senza poter
 sfruttare veri e propri automatismi.
 Una forte limitazione del sistema operativo è dovuta, per esempio, al fatto
 che l'unico thread che ha il permesso di accedere e di modificare l'interfaccia
 utente è il Main Thread, cioè il processo principale sul quale viene avviata
 l'applicazione; questo complica l'interazione con sistemi multithreading
 anche se, ovviamente, fa parte delle specifiche di sistema utili a limitare
 i problemi durante l'accesso alle risorse condivise (in questo caso le
 view).
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Questo problema necessita di ampia valutazione durante lo sviluppo e anche
 in questo caso si è dovuto strutturare l'applicazione in modo che non incorress
e in errori di inconsistenza tra le view a cui il programma voleva accedere
 e le view realmente visualizzate al momento.
 Nel caso si utilizzino script asincroni è molto facile tentare di accedere
 a elementi, o anche intere schermate, non più presenti a video; per questo
 motivo si è scelto di utilizzare la libreria EventBus sviluppata da GreenRobot
 
\begin_inset CommandInset citation
LatexCommand cite
key "GITHUB:EVENTBUS"

\end_inset

 e pensata esattamente per gestire e risolvere questo tipo di problemi.
\end_layout

\begin_layout Subsection
EventBus
\end_layout

\begin_layout Standard
EventBus è una libreria open-source per Android che utilizza il pattern
 publish/subscribe per far dialogare tutti i componenti di un'applicazione.
 Disaccoppia le classi che interagiscono sulla stessa interfaccia e le gestisce
 in maniera centralizzata monitorando le performance e gestendo gli errori
 che potrebbero essere sollevati da uno sviluppo multithread.
 
\begin_inset CommandInset citation
LatexCommand cite
key "GREENROBOT:EVENTBUS"

\end_inset


\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
I principali benefici che si riscontrano tramite l'utilizzo di questa libreria
 sono la semplificazione delle comunicazioni tra componenti, il disaccoppiamento
 tra mittenti e riceventi degli eventi, miglioramenti nelle perfomance,
 facile integrazione dei metodi da utilizzare ed infine anche caratteristiche
 avanzate come priorità e indirizzamento a thread specifici.
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Durante lo svolgimento di questa tesi si è definita una struttura abbastanza
 comune formata da: 
\end_layout

\begin_layout Itemize
AsyncTask, oggetto che permette di elaborare una serie di informazioni in
 background, utilizzato per eseguire il download delle informazioni dal
 server; 
\end_layout

\begin_layout Itemize
View specifica dell'activity con determinati componenti da aggiornare in
 base allo stato dell'applicazione; 
\end_layout

\begin_layout Itemize
Metodo 
\emph on
updateUI()
\emph default
 che presi in ingresso i dati scaricati doveva aggiornare le view rispetto
 allo stato.
\end_layout

\begin_layout Standard
Per far dialogare questi elementi si è utilizzato EventBus così da sfruttare
 il lavoro di thread in background senza limitare l'utente nell'attesa di
 un determinato evento.
 Si procedeva quindi creando un evento specifico per l'interazione da dover
 gestire di cui qui viene riportato un esempio:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public static class UpdateCouponUiEvent<T> {
\end_layout

\begin_layout Plain Layout

	public T data;
\end_layout

\begin_layout Plain Layout

	public UpdateCouponUiEvent(T data) {
\end_layout

\begin_layout Plain Layout

		this.data = data;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Event Class
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
EventBus permette di registrare dei metodi eseguendo una subscribe a un
 determinato evento: ogni qual volta un evento di quel tipo viene sollevato,
 il metodo viene eseguito.
 La subscribe deve essere definita nel codice nel seguente modo:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

@Subscribe
\end_layout

\begin_layout Plain Layout

public void updateUI(UpdateCouponUiEvent event) {
\end_layout

\begin_layout Plain Layout

	// update UI with event.data
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
EventBus Subscribe
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Grazie all'utilizzo di eventi custom è dunque possibile passare anche dei
 dati tramite l'evento che viene lanciato all'interno di un AsyncTask, a
 conclusione del download delle informazioni e dell'aggiornamento dello
 stato, grazie a una publish:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

EventBus.getDefault().post(new UpdateCouponUiEvent());
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
EventBus Update
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
E-Commerce
\end_layout

\begin_layout Standard
Ogni sistema di e-commerce presente sugli applicativi moderni è normalmente
 basato su alcune delle librerie più diffuse nell'ambito dei pagamenti online.
 La sicurezza e l'affidabilità che questo tipo di sistemi devono assolutamente
 garantire rende necessario l'uso di tool testati e specifici per l'utilizzo.
 Questi sistemi ovviamente devono garantire l'utilizzo sia da parte dell'applica
tivo di frontend sia da parte del server di backend in modo che l'intero
 sistema sia consistente.
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout Standard
In questo specifico caso si è scelto di utilizzare il tool Stripe, 
\begin_inset CommandInset citation
LatexCommand cite
key "STRIPE"

\end_inset

 piattaforma per i pagamenti online disponibile anche come plugin da poter
 importare all'interno del proprio progetto che permette di avere una gestione
 dei metodi di pagamento di un singolo utente e di eseguire transizioni
 monetarie tra un account user e un account commerciante.
\end_layout

\begin_layout Subsection
Stripe
\end_layout

\begin_layout Standard
L'implementazione di Stripe richiede un'inizializzazione da parte del sistema
 di backend della piattaforma, il quale espone poi per ogni account un token
 identificativo che sarà necessario per le richieste effettuate tramite
 la piattaforma Stripe.
 Ogni token viene inserito all'interno dei dati del singolo account in modo
 che grazie all'utilizzo del plugin importato come dipendenza all'interno
 del progetto Android sia possibile richiedere i metodi di pagamento già
 collegati all'account selezionato e nel caso aggiungerne di nuovi.
 Questo sistema non esporrà mai le informazioni sensibili e riservate date
 dall'utente all'aggiunta di una carta poichè saranno gestite internamente
 alla libreria e salvate solo sul sistema di e-commerce.
 Gli unici dati, utili all'identificazione e alla scelta di volta in volta
 del metodo di pagamento saranno solo le ultime quattro cifre della carta
 e la data di scadenza.
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Nel momento in cui si vorrà eseguire una transizione monetaria tra due account
 sarà necessario avere il token identificativo dell'utente e quello dell'eserciz
io su cui si vorrà acquistare, in questo caso le gelateria inserite all'interno
 del circuito MyGelato.
 Interverrà poi il sistema di pagamento interno alla piattaforma Stripe
 per effettuare il passaggio e concludere la transizione in sicurezza e
 con l'affidabilità di un alto controllo sugli errori.
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Oltre alla semplicità di utilizzo di un tool di questo tipo che permette
 l'inserimento di pagamenti online all'interno dei propri progetti anche
 senza una specifica esperienza nel campo, è fondamentale la parte di test
 resa disponibile da Stripe che permette di aggiungere dei metodi di pagamento
 non reali e di eseguire delle transizioni senza che vi sia un reale spostamento
 monetario ai fine del testing dei proprio applicativi.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\end_body
\end_document
